import threading
from redis.commands import CoreCommands as CoreCommands, RedisModuleCommands as RedisModuleCommands, list_or_args as list_or_args
from redis.connection import (
    ConnectionPool as ConnectionPool,
    SSLConnection as SSLConnection,
    UnixDomainSocketConnection as UnixDomainSocketConnection,
)
from redis.exceptions import (
    ConnectionError as ConnectionError,
    ExecAbortError as ExecAbortError,
    ModuleError as ModuleError,
    NoScriptError as NoScriptError,
    PubSubError as PubSubError,
    RedisError as RedisError,
    ResponseError as ResponseError,
    TimeoutError as TimeoutError,
    WatchError as WatchError,
)
from redis.lock import Lock as Lock
from redis.utils import safe_str as safe_str, str_if_bytes as str_if_bytes
from typing import Any

SYM_EMPTY: bytes
EMPTY_RESPONSE: str

def timestamp_to_datetime(response): ...
def string_keys_to_dict(key_string, callback): ...

class CaseInsensitiveDict(dict):
    def __init__(self, data) -> None: ...
    def __contains__(self, k): ...
    def __delitem__(self, k) -> None: ...
    def __getitem__(self, k): ...
    def get(self, k, default: Any | None = ...): ...
    def __setitem__(self, k, v) -> None: ...
    def update(self, data) -> None: ...

def parse_debug_object(response): ...
def parse_object(response, infotype): ...
def parse_info(response): ...
def parse_memory_stats(response, **kwargs): ...

SENTINEL_STATE_TYPES: Any

def parse_sentinel_state(item): ...
def parse_sentinel_master(response): ...
def parse_sentinel_masters(response): ...
def parse_sentinel_slaves_and_sentinels(response): ...
def parse_sentinel_get_master(response): ...
def pairs_to_dict(response, decode_keys: bool = ..., decode_string_values: bool = ...): ...
def pairs_to_dict_typed(response, type_info): ...
def zset_score_pairs(response, **options): ...
def sort_return_tuples(response, **options): ...
def int_or_none(response): ...
def parse_stream_list(response): ...
def pairs_to_dict_with_str_keys(response): ...
def parse_list_of_dicts(response): ...
def parse_xclaim(response, **options): ...
def parse_xautoclaim(response, **options): ...
def parse_xinfo_stream(response, **options): ...
def parse_xread(response): ...
def parse_xpending(response, **options): ...
def parse_xpending_range(response): ...
def float_or_none(response): ...
def bool_ok(response): ...
def parse_zadd(response, **options): ...
def parse_client_list(response, **options): ...
def parse_config_get(response, **options): ...
def parse_scan(response, **options): ...
def parse_hscan(response, **options): ...
def parse_zscan(response, **options): ...
def parse_zmscore(response, **options): ...
def parse_slowlog_get(response, **options): ...
def parse_stralgo(response, **options): ...
def parse_cluster_info(response, **options): ...
def parse_cluster_nodes(response, **options): ...
def parse_geosearch_generic(response, **options): ...
def parse_pubsub_numsub(response, **options): ...
def parse_client_kill(response, **options): ...
def parse_acl_getuser(response, **options): ...
def parse_acl_log(response, **options): ...
def parse_client_info(value): ...
def parse_module_result(response): ...
def parse_set_result(response, **options): ...

class Redis(RedisModuleCommands, CoreCommands):
    RESPONSE_CALLBACKS: Any
    @classmethod
    def from_url(cls, url, **kwargs): ...
    connection_pool: Any
    connection: Any
    response_callbacks: Any
    def __init__(
        self,
        host: str = ...,
        port: int = ...,
        db: int = ...,
        password: Any | None = ...,
        socket_timeout: Any | None = ...,
        socket_connect_timeout: Any | None = ...,
        socket_keepalive: Any | None = ...,
        socket_keepalive_options: Any | None = ...,
        connection_pool: Any | None = ...,
        unix_socket_path: Any | None = ...,
        encoding: str = ...,
        encoding_errors: str = ...,
        charset: Any | None = ...,
        errors: Any | None = ...,
        decode_responses: bool = ...,
        retry_on_timeout: bool = ...,
        ssl: bool = ...,
        ssl_keyfile: Any | None = ...,
        ssl_certfile: Any | None = ...,
        ssl_cert_reqs: str = ...,
        ssl_ca_certs: Any | None = ...,
        ssl_check_hostname: bool = ...,
        max_connections: Any | None = ...,
        single_connection_client: bool = ...,
        health_check_interval: int = ...,
        client_name: Any | None = ...,
        username: Any | None = ...,
        retry: Any | None = ...,
    ) -> None: ...
    def set_response_callback(self, command, callback) -> None: ...
    def load_external_module(self, funcname, func) -> None: ...
    def pipeline(self, transaction: bool = ..., shard_hint: Any | None = ...): ...
    def transaction(self, func, *watches, **kwargs): ...
    def lock(
        self,
        name,
        timeout: Any | None = ...,
        sleep: float = ...,
        blocking_timeout: Any | None = ...,
        lock_class: Any | None = ...,
        thread_local: bool = ...,
    ): ...
    def pubsub(self, **kwargs): ...
    def monitor(self): ...
    def client(self): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def execute_command(self, *args, **options): ...
    def parse_response(self, connection, command_name, **options): ...

StrictRedis = Redis

class Monitor:
    monitor_re: Any
    command_re: Any
    connection_pool: Any
    connection: Any
    def __init__(self, connection_pool) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...
    def next_command(self): ...
    def listen(self) -> None: ...

class PubSub:
    PUBLISH_MESSAGE_TYPES: Any
    UNSUBSCRIBE_MESSAGE_TYPES: Any
    HEALTH_CHECK_MESSAGE: str
    connection_pool: Any
    shard_hint: Any
    ignore_subscribe_messages: Any
    connection: Any
    encoder: Any
    health_check_response: Any
    def __init__(self, connection_pool, shard_hint: Any | None = ..., ignore_subscribe_messages: bool = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    channels: Any
    pending_unsubscribe_channels: Any
    patterns: Any
    pending_unsubscribe_patterns: Any
    def reset(self) -> None: ...
    def close(self) -> None: ...
    def on_connect(self, connection) -> None: ...
    @property
    def subscribed(self): ...
    def execute_command(self, *args) -> None: ...
    def parse_response(self, block: bool = ..., timeout: int = ...): ...
    def check_health(self) -> None: ...
    def psubscribe(self, *args, **kwargs): ...
    def punsubscribe(self, *args): ...
    def subscribe(self, *args, **kwargs): ...
    def unsubscribe(self, *args): ...
    def listen(self) -> None: ...
    def get_message(self, ignore_subscribe_messages: bool = ..., timeout: int = ...): ...
    def ping(self, message: Any | None = ...): ...
    def handle_message(self, response, ignore_subscribe_messages: bool = ...): ...
    def run_in_thread(self, sleep_time: int = ..., daemon: bool = ..., exception_handler: Any | None = ...): ...

class PubSubWorkerThread(threading.Thread):
    daemon: Any
    pubsub: Any
    sleep_time: Any
    exception_handler: Any
    def __init__(self, pubsub, sleep_time, daemon: bool = ..., exception_handler: Any | None = ...) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...

class Pipeline(Redis):
    UNWATCH_COMMANDS: Any
    connection_pool: Any
    connection: Any
    response_callbacks: Any
    transaction: Any
    shard_hint: Any
    watching: bool
    def __init__(self, connection_pool, response_callbacks, transaction, shard_hint) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    def __len__(self): ...
    def __bool__(self): ...
    command_stack: Any
    scripts: Any
    explicit_transaction: bool
    def reset(self) -> None: ...
    def multi(self) -> None: ...
    def execute_command(self, *args, **kwargs): ...
    def immediate_execute_command(self, *args, **options): ...
    def pipeline_execute_command(self, *args, **options): ...
    def raise_first_error(self, commands, response) -> None: ...
    def annotate_exception(self, exception, number, command) -> None: ...
    def parse_response(self, connection, command_name, **options): ...
    def load_scripts(self) -> None: ...
    def execute(self, raise_on_error: bool = ...): ...
    def discard(self) -> None: ...
    def watch(self, *names): ...
    def unwatch(self): ...

class Script:
    registered_client: Any
    script: Any
    sha: Any
    def __init__(self, registered_client, script) -> None: ...
    def __call__(self, keys=..., args=..., client: Any | None = ...): ...
